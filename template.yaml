AWSTemplateFormatVersion: '2010-09-09'
Description: >
  This template creates a CodePipeline pipeline with a source stage (Github), a build stage (CodeBuild), and a deploy stage (ECS).

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "AWS Configuration"
        Parameters:
          - AccountID
          - Region
      - Label:
          default: "Repository Configuration"
        Parameters:
          - AppRepositoryName
          - TestRepositoryName
          - RepositoryBranch
          - ConnectionArn
      - Label:
          default: "Storage Configuration"
        Parameters:
          - BuildArtifactBucketName
          - PlaywrightReportsBucketName
          - ECRRepositoryName
      - Label:
          default: "Build Configuration"
        Parameters:
          - BuildProjectName
          - TestProjectName
          - BuildImageName
          - TestImageName
          - ComputeType
          - TimeoutMinutes
      - Label:
          default: "Deployment Configuration"
        Parameters:
          - ECSClusterName
          - ECSServiceName
          - PipelineName
    ParameterLabels:
      AccountID:
        default: "AWS Account ID"
      Region:
        default: "AWS Region"
      BuildArtifactBucketName:
        default: "Build Artifact Bucket Name"
      PlaywrightReportsBucketName:
        default: "Playwright Reports Bucket Name"

Parameters:
  AccountID:
    Type: String
    Description: "AWS Account ID"
  
  Region:
    Type: String
    Default: 'ap-northeast-1'
    Description: "AWS Region"
  
  NotificationEmail:
    Type: String
    Default: 'your-email@example.com'
    Description: "Email address to receive pipeline notifications"
  
  SlackWebhookUrl:
    Type: String
    Default: 'https://hooks.slack.com/services/TXXXXXXXX/BXXXXXXXX/XXXXXXXXXXXXXXXXXXXXXXXX'
    Description: "Slack webhook URL for notifications"
    NoEcho: true
  
  BuildArtifactBucketName:
    Type: String
    Default: 'codepipeline-ap-northeast-1-artifacts-iac-v3'
    Description: "Build artifactBucket"
  
  PlaywrightReportsBucketName:
    Type: String
    Default: 'playwright-reports-v1'
    Description: "Playwright's test Reports"
  
  ECRRepositoryName:
    Type: String
    Default: 'flask_ecs_test'
    Description: "Where to store Container(Docker) images"
  
  AppRepositoryName:
    Type: String
    Default: 'flask_ecs_test'
    Description: "Application repository name"
  
  TestRepositoryName:
    Type: String
    Default: 'PlaywrightDemoTest'
    Description: "Test repository name"
  
  AppRepositoryBranch:
    Type: String
    # Default: 'master'
    Default: 'contains_bugs'
    Description: "Repository branch of Application"

  TestRepositoryBranch:
    Type: String
    Default: 'master'
    Description: "Repository branch of Test code"
  
  ConnectionArn:
    Type: String
    Default: 'arn:aws:codeconnections:ap-northeast-1:761018867077:connection/3d2919d6-6060-4176-865f-cf1932600cbc'
    Description: "CodeStar connection ARN for GitHub"
  
  ECSClusterName:
    Type: String
    Default: 'sample-ecs-cluster'
    Description: "ECS cluster name"
  
  ECSServiceName:
    Type: String
    Default: 'test-service'
    Description: "ECS service name"
  
  BuildProjectName:
    Type: String
    Default: 'cloudformation_sample'
    Description: "Name for the build project"
  
  TestProjectName:
    Type: String
    Default: 'PlaywrightDemoTest'
    Description: "Name for the test project"
  
  BuildImageName:
    Type: String
    Default: 'aws/codebuild/standard:7.0'
    Description: "Docker image for build"
  
  TestImageName:
    Type: String
    Default: 'aws/codebuild/standard:6.0'
    #Default: 'mcr.microsoft.com/playwright:v1.51.0-noble'
    Description: "Docker image for test"
  
  ComputeType:
    Type: String
    Default: 'BUILD_GENERAL1_MEDIUM'
    AllowedValues:
      - 'BUILD_GENERAL1_SMALL'
      - 'BUILD_GENERAL1_MEDIUM'
      - 'BUILD_GENERAL1_LARGE'
    Description: "CodeBuild compute type"
  
  PipelineName:
    Type: String
    Default: 'pipeline_sample'
    Description: "Name for the CodePipeline"
  
  TimeoutMinutes:
    Type: Number
    Default: 45
    MinValue: 5
    MaxValue: 480
    Description: "Timeout in minutes for build and test projects"

# Tags define
Mappings:
  TagMap:
    DefaultTags:
      Project: "CI/CD Pipeline"
      Environment: "Demo"
      ManagedBy: "CloudFormation"

Resources:
  #-----------------------------------------------------------------------------
  # Storage Resources
  #-----------------------------------------------------------------------------
  ArtifactBucket:
    Type: 'AWS::S3::Bucket'
    Properties:
      BucketName: !Sub ${BuildArtifactBucketName}
      VersioningConfiguration:
        Status: Enabled
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-ArtifactBucket"
        - Key: Project
          Value: !FindInMap [TagMap, DefaultTags, Project]
        - Key: Environment
          Value: !FindInMap [TagMap, DefaultTags, Environment]
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
  
  PlaywrightReportsBucket:
    Type: 'AWS::S3::Bucket'
    Properties:
      BucketName: !Sub ${PlaywrightReportsBucketName}
      PublicAccessBlockConfiguration:
        BlockPublicAcls: false
        BlockPublicPolicy: false
        IgnorePublicAcls: false
        RestrictPublicBuckets: false
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldReports
            Status: Enabled
            ExpirationInDays: 30
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders:
              - '*'
            AllowedMethods:
              - GET
              - HEAD
            AllowedOrigins:
              - '*'
            MaxAge: 3600
      WebsiteConfiguration:
        IndexDocument: index.html
        ErrorDocument: error.html
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-PlaywrightReportsBucket"
        - Key: Project
          Value: !FindInMap [TagMap, DefaultTags, Project]
        - Key: Environment
          Value: !FindInMap [TagMap, DefaultTags, Environment]
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete

  PlaywrightReportsBucketPolicy:
    Type: 'AWS::S3::BucketPolicy'
    Properties:
      Bucket: !Ref PlaywrightReportsBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal: '*'
            Action:
              - 's3:GetObject'
            Resource: !Sub 'arn:aws:s3:::${PlaywrightReportsBucketName}/*'
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
  
  ECRRepository:
    Type: 'AWS::ECR::Repository'
    Properties:
      RepositoryName: !Sub ${ECRRepositoryName}
      LifecyclePolicy:
        LifecyclePolicyText: |
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep only the last 10 images",
                "selection": {
                  "tagStatus": "any",
                  "countType": "imageCountMoreThan",
                  "countNumber": 10
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-ECRRepository"
        - Key: Project
          Value: !FindInMap [TagMap, DefaultTags, Project]
        - Key: Environment
          Value: !FindInMap [TagMap, DefaultTags, Environment]

  #-----------------------------------------------------------------------------
  # Notification Resources
  #-----------------------------------------------------------------------------
  PipelineNotificationTopic:
    Type: 'AWS::SNS::Topic'
    Properties:
      DisplayName: !Sub "${AWS::StackName}-Pipeline-Notifications"
      TopicName: !Sub "${AWS::StackName}-Pipeline-Notifications"
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-PipelineNotificationTopic"
        - Key: Project
          Value: !FindInMap [TagMap, DefaultTags, Project]
        - Key: Environment
          Value: !FindInMap [TagMap, DefaultTags, Environment]

  SNSTopicPolicy:
    Type: 'AWS::SNS::TopicPolicy'
    Properties:
      Topics:
        - !Ref PipelineNotificationTopic
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: 'AllowCodePipelinePublish'
            Effect: Allow
            Principal:
              Service:
                - 'codepipeline.amazonaws.com'
                - 'codebuild.amazonaws.com'
                - 'codestar-notifications.amazonaws.com'
            Action: 'sns:Publish'
            Resource: !Ref PipelineNotificationTopic
          - Sid: 'AllowOwnerPublish'
            Effect: Allow
            Principal: '*'
            Action: 'sns:Publish'
            Resource: !Ref PipelineNotificationTopic
            Condition:
              StringEquals:
                'AWS:SourceOwner': !Ref 'AWS::AccountId'

  # メール通知用のSNSサブスクリプション（raw形式で送信し、カスタムサブジェクトを使用）
  EmailSubscription:
    Type: 'AWS::SNS::Subscription'
    Properties:
      Protocol: email
      TopicArn: !Ref PipelineNotificationTopic
      Endpoint: !Ref NotificationEmail
      FilterPolicy:
        source:
          - 'aws.codepipeline'
      RawMessageDelivery: true

  # メール通知用のSNSサブジェクト変換Lambda
  EmailNotificationForwarder:
    Type: 'AWS::Lambda::Function'
    Properties:
      FunctionName: !Sub "${AWS::StackName}-email-forwarder"
      Handler: index.handler
      Role: !GetAtt EmailNotificationForwarderRole.Arn
      Runtime: nodejs20.x
      Timeout: 30
      MemorySize: 256
      Environment:
        Variables:
          EMAIL_SNS_TOPIC_ARN: !Ref PipelineNotificationTopic
          REGION: !Ref Region
      Code:
        ZipFile: |
          const { SNSClient, PublishCommand } = require('@aws-sdk/client-sns');
          
          // SNSクライアントの初期化
          const snsClient = new SNSClient({ region: process.env.REGION });
          
          exports.handler = async (event) => {
              console.log('Event received:', JSON.stringify(event, null, 2));
              
              try {
                  if (!event.Records || !event.Records[0] || !event.Records[0].Sns) {
                      console.error('Invalid event structure:', JSON.stringify(event));
                      return { statusCode: 400, body: 'Invalid event structure' };
                  }

                  // SNSメッセージを解析
                  const snsMessage = event.Records[0].Sns;
                  const messageStr = snsMessage.Message;
                  
                  let parsedMessage;
                  try {
                      // JSONの場合はパース
                      parsedMessage = JSON.parse(messageStr);
                  } catch (e) {
                      console.error('JSONパースエラー:', e);
                      return { statusCode: 200, body: 'Non-JSON message ignored' };
                  }
                  
                  // パイプラインの状態を取得
                  const state = parsedMessage.detail?.state;
                  const pipelineName = parsedMessage.detail?.pipeline || 
                                      parsedMessage.resources?.[0]?.split(':').pop() ||
                                      '不明なパイプライン';
                  
                  // 状態に応じたメッセージを作成
                  let subject, message;
                  const timestamp = new Date().toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' });
                  
                  if (state === 'STARTED') {
                      subject = `【開始】パイプライン「${pipelineName}」の実行が開始されました`;
                      message = `
===========================================
パイプライン実行開始
===========================================

パイプライン「${pipelineName}」の実行が開始されました。

時刻: ${timestamp}
`;
                  } else if (state === 'SUCCEEDED') {
                      subject = `【成功】パイプライン「${pipelineName}」の実行が成功しました`;
                      message = `
===========================================
パイプライン実行成功
===========================================

パイプライン「${pipelineName}」の実行が正常に完了しました。

時刻: ${timestamp}
`;
                  } else if (state === 'FAILED') {
                      // 失敗した場所の情報を抽出
                      const failedStage = parsedMessage.detail?.stage || '不明';
                      const failedAction = parsedMessage.detail?.action || '不明';
                      let failureInfo = '';
                      
                      if (failedStage !== '不明') {
                          failureInfo = `ステージ「${failedStage}」`;
                          if (failedAction !== '不明') {
                              failureInfo += `のアクション「${failedAction}」`;
                          }
                      }
                      
                      subject = `【失敗】パイプライン「${pipelineName}」の実行が失敗しました`;
                      message = `
===========================================
パイプライン実行失敗
===========================================

パイプライン「${pipelineName}」の実行が失敗しました。

`;
                      if (failureInfo) {
                          message += `失敗箇所: ${failureInfo}\n\n`;
                      }
                      
                      message += `時刻: ${timestamp}`;
                  } else {
                      // 対象外の状態はスキップ
                      console.log('対象外の状態のため通知をスキップします:', state);
                      return { statusCode: 200, body: 'State ignored' };
                  }
                  
                  // 整形したメッセージをSNSに再発行
                  try {
                      const params = {
                          TopicArn: process.env.EMAIL_SNS_TOPIC_ARN,
                          Subject: subject,
                          Message: message,
                          MessageAttributes: {
                              'source': {
                                  DataType: 'String',
                                  StringValue: 'aws.codepipeline.formatted'
                              }
                          }
                      };
                      
                      const command = new PublishCommand(params);
                      const response = await snsClient.send(command);
                      console.log('SNS message published successfully:', response);
                      return { statusCode: 200, body: 'Message forwarded successfully' };
                  } catch (error) {
                      console.error('SNS publish error:', error);
                      throw error;
                  }
              } catch (error) {
                  console.error('Error processing message:', error);
                  return { statusCode: 500, body: `Error: ${error.message}` };
              }
          };
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-EmailNotificationForwarder"
        - Key: Project
          Value: !FindInMap [TagMap, DefaultTags, Project]
        - Key: Environment
          Value: !FindInMap [TagMap, DefaultTags, Environment]

  EmailNotificationForwarderRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Principal:
              Service:
                - 'lambda.amazonaws.com'
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: 'EmailForwarderPolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: 'Allow'
                Action:
                  - 'sns:Publish'
                Resource: !Ref PipelineNotificationTopic
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-EmailNotificationForwarderRole"
        - Key: Project
          Value: !FindInMap [TagMap, DefaultTags, Project]
        - Key: Environment
          Value: !FindInMap [TagMap, DefaultTags, Environment]

  EmailNotificationForwarderSubscription:
    Type: 'AWS::SNS::Subscription'
    Properties:
      Protocol: lambda
      TopicArn: !Ref PipelineNotificationTopic
      Endpoint: !GetAtt EmailNotificationForwarder.Arn
      FilterPolicy:
        source:
          - 'aws.codepipeline'
          - 'aws.codestar-notifications'

  EmailNotificationForwarderPermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !Ref EmailNotificationForwarder
      Principal: 'sns.amazonaws.com'
      SourceArn: !Ref PipelineNotificationTopic

  # EmailSubscriptionで受信するメッセージを整形済みのものだけに限定
  FormattedEmailSubscription:
    Type: 'AWS::SNS::Subscription'
    Properties:
      Protocol: email
      TopicArn: !Ref PipelineNotificationTopic
      Endpoint: !Ref NotificationEmail
      FilterPolicy:
        source:
          - 'aws.codepipeline.formatted'

  SlackNotificationFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      FunctionName: !Sub "${AWS::StackName}-slack-notification"
      Handler: index.handler
      Role: !GetAtt SlackNotificationRole.Arn
      Runtime: nodejs20.x
      Timeout: 30
      MemorySize: 256
      Environment:
        Variables:
          SLACK_WEBHOOK_URL: !Ref SlackWebhookUrl
          PLAYWRIGHT_REPORTS_BUCKET: !Ref PlaywrightReportsBucket
          REGION: !Ref Region
      Code:
        ZipFile: |
          const https = require('https');
          const { S3Client, ListObjectsV2Command } = require('@aws-sdk/client-s3');
          
          // S3クライアントの初期化
          const s3Client = new S3Client({ region: process.env.REGION });
          
          exports.handler = async (event) => {
              console.log('Event received:', JSON.stringify(event, null, 2));
              
              try {
                  if (!event.Records || !event.Records[0] || !event.Records[0].Sns) {
                      console.error('Invalid event structure:', JSON.stringify(event));
                      return {
                          statusCode: 400,
                          body: 'Invalid event structure'
                      };
                  }

                  // SNSメッセージを解析
                  const snsMessage = event.Records[0].Sns;
                  const messageStr = snsMessage.Message;
                  
                  console.log('SNS Message:', messageStr);
                  
                  let parsedMessage;
                  try {
                      // JSONの場合はパース
                      parsedMessage = JSON.parse(messageStr);
                  } catch (e) {
                      // テキストメッセージの場合はそのまま使用
                      console.error('JSONパースエラー:', e);
                      parsedMessage = messageStr;
                      return {
                          statusCode: 200,
                          body: 'Non-JSON message ignored'
                      };
                  }
                  
                  // メッセージの詳細を取得
                  const detailType = parsedMessage['detail-type'];
                  const source = parsedMessage.source;
                  const state = parsedMessage.detail?.state;
                  const pipelineName = parsedMessage.detail?.pipeline || 
                                      parsedMessage.resources?.[0]?.split(':').pop() ||
                                      '不明なパイプライン';
                  
                  console.log(`Source: ${source}, DetailType: ${detailType}, State: ${state}, Pipeline: ${pipelineName}`);
                  
                  // フィルタリング - パイプライン実行のステータス通知に絞る
                  const isCodePipelineEvent = source === 'aws.codepipeline' || 
                                              (source === 'aws.codestar-notifications' && 
                                               detailType === 'CodePipeline Pipeline Execution State Change');
                                               
                  if (!isCodePipelineEvent) {
                      console.log('イベントタイプが対象外のため通知をスキップします:', source, detailType);
                      return {
                          statusCode: 200,
                          body: 'Event type ignored'
                      };
                  }
                  
                  // シンプルなメッセージを作成
                  let title, message, color;
                  
                  if (state === 'STARTED') {
                      title = `📣 パイプライン実行開始`;
                      message = `パイプライン「${pipelineName}」の実行が開始されました`;
                      color = '#3AA3E3'; // 青色
                  } else if (state === 'SUCCEEDED') {
                      title = `✅ パイプライン実行成功`;
                      message = `パイプライン「${pipelineName}」の実行が正常に完了しました`;
                      color = '#36a64f'; // 緑色
                      
                      // テスト結果レポートのリンク取得（テストステージがある場合）
                      try {
                          const reportUrl = await getLatestTestReportUrl();
                          if (reportUrl) {
                              message += `\n\n*テスト結果レポート*: <${reportUrl}|こちらから確認できます>`;
                          }
                      } catch (error) {
                          console.error('テストレポートURL取得エラー:', error);
                      }
                  } else if (state === 'FAILED') {
                      title = `❌ パイプライン実行失敗`;
                      message = `パイプライン「${pipelineName}」の実行が失敗しました`;
                      
                      // 失敗した場所の情報を抽出（可能な場合）
                      const failedStage = parsedMessage.detail?.stage || '不明';
                      const failedAction = parsedMessage.detail?.action || '不明';
                      if (failedStage !== '不明') {
                          message += `\n\n*失敗箇所*: ステージ「${failedStage}」`;
                          if (failedAction !== '不明') {
                              message += `のアクション「${failedAction}」`;
                          }
                      }
                      
                      color = '#ff0000'; // 赤色
                  } else {
                      console.log('対象外の状態のため通知をスキップします:', state);
                      return {
                          statusCode: 200,
                          body: 'State ignored'
                      };
                  }
                  
                  // Slackメッセージを構築
                  const slackMessage = {
                      blocks: [
                          {
                              type: "header",
                              text: {
                                  type: "plain_text",
                                  text: title,
                                  emoji: true
                              }
                          },
                          {
                              type: "section",
                              text: {
                                  type: "mrkdwn",
                                  text: message
                              }
                          },
                          {
                              type: "context",
                              elements: [
                                  {
                                      type: "mrkdwn",
                                      text: `*時刻*: ${new Date().toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' })}`
                                  }
                              ]
                          }
                      ]
                  };
                  
                  console.log('Slack message:', JSON.stringify(slackMessage));
                  
                  // Slackに送信
                  const webhookUrl = process.env.SLACK_WEBHOOK_URL;
                  if (!webhookUrl) {
                      throw new Error('SLACK_WEBHOOK_URL環境変数が設定されていません');
                  }
                  
                  const parsedUrl = new URL(webhookUrl);
                  const options = {
                      hostname: parsedUrl.hostname,
                      path: parsedUrl.pathname + parsedUrl.search,
                      method: 'POST',
                      headers: {
                          'Content-Type': 'application/json'
                      }
                  };
                  
                  const response = await sendToSlack(options, slackMessage);
                  console.log('Slack response:', response);
                  
                  return {
                      statusCode: 200,
                      body: 'Message sent to Slack successfully'
                  };
              } catch (error) {
                  console.error('Error processing message:', error);
                  return {
                      statusCode: 500,
                      body: `Error: ${error.message}`
                  };
              }
          };
          
          // S3から最新のテストレポートのURLを取得する関数
          async function getLatestTestReportUrl() {
              try {
                  const bucketName = process.env.PLAYWRIGHT_REPORTS_BUCKET;
                  if (!bucketName) {
                      throw new Error('PLAYWRIGHT_REPORTS_BUCKET環境変数が設定されていません');
                  }
                  
                  // S3バケットの最新のオブジェクトを取得
                  const command = new ListObjectsV2Command({
                      Bucket: bucketName,
                      Prefix: 'report-',  // テストレポートのプレフィックスがあれば指定
                      MaxKeys: 10
                  });
                  
                  const response = await s3Client.send(command);
                  if (!response.Contents || response.Contents.length === 0) {
                      console.log('テストレポートが見つかりませんでした');
                      return null;
                  }
                  
                  // 最新のフォルダを特定（LastModifiedで並べ替え）
                  const latestObject = response.Contents.sort((a, b) => 
                      new Date(b.LastModified) - new Date(a.LastModified)
                  )[0];
                  
                  // index.htmlへのパスを構築
                  let reportPath;
                  if (latestObject.Key.endsWith('/')) {
                      reportPath = `${latestObject.Key}index.html`;
                  } else if (latestObject.Key.endsWith('index.html')) {
                      reportPath = latestObject.Key;
                  } else {
                      // ディレクトリの場合はindex.htmlを追加、そうでない場合はそのまま
                      reportPath = latestObject.Key.includes('/') && !latestObject.Key.endsWith('/') 
                          ? latestObject.Key 
                          : `${latestObject.Key}/index.html`;
                  }
                  
                  // S3ウェブサイトエンドポイントURL
                  const websiteUrl = `https://${bucketName}.s3-website-${process.env.REGION}.amazonaws.com/${reportPath}`;
                  console.log('テストレポートURL:', websiteUrl);
                  
                  return websiteUrl;
              } catch (error) {
                  console.error('S3レポート取得エラー:', error);
                  return null;
              }
          }
          
          function sendToSlack(options, message) {
              return new Promise((resolve, reject) => {
                  const req = https.request(options, (res) => {
                      let responseBody = '';
                      res.on('data', (chunk) => {
                          responseBody += chunk;
                      });
                      res.on('end', () => {
                          if (res.statusCode >= 200 && res.statusCode < 300) {
                              resolve({
                                  statusCode: res.statusCode,
                                  body: responseBody
                              });
                          } else {
                              console.error(`Slack返答エラー: ${res.statusCode} ${responseBody}`);
                              reject(new Error(`Slack API returned status code ${res.statusCode}: ${responseBody}`));
                          }
                      });
                  });
                  
                  req.on('error', (err) => {
                      console.error('Slackへの送信エラー:', err);
                      reject(err);
                  });
                  
                  req.write(JSON.stringify(message));
                  req.end();
              });
          }
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-SlackNotificationFunction"
        - Key: Project
          Value: !FindInMap [TagMap, DefaultTags, Project]
        - Key: Environment
          Value: !FindInMap [TagMap, DefaultTags, Environment]

  SlackSubscription:
    Type: 'AWS::SNS::Subscription'
    Properties:
      Protocol: lambda
      TopicArn: !Ref PipelineNotificationTopic
      Endpoint: !GetAtt SlackNotificationFunction.Arn
      FilterPolicy:
        source:
          - 'aws.codepipeline'
          - 'aws.codestar-notifications'

  LambdaPermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !Ref SlackNotificationFunction
      Principal: 'sns.amazonaws.com'
      SourceArn: !Ref PipelineNotificationTopic

  SlackNotificationRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Principal:
              Service:
                - 'lambda.amazonaws.com'
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: 'SlackNotificationPolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: 'Allow'
                Action:
                  - 's3:ListBucket'
                  - 's3:GetObject'
                Resource:
                  - !Sub 'arn:aws:s3:::${PlaywrightReportsBucketName}'
                  - !Sub 'arn:aws:s3:::${PlaywrightReportsBucketName}/*'
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-SlackNotificationRole"
        - Key: Project
          Value: !FindInMap [TagMap, DefaultTags, Project]
        - Key: Environment
          Value: !FindInMap [TagMap, DefaultTags, Environment]

  #-----------------------------------------------------------------------------
  # IAM Resources
  #-----------------------------------------------------------------------------
  CodePipelineRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Principal:
              Service:
                - 'codepipeline.amazonaws.com'
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess'
      Policies:
        - PolicyName: 'CodePipelinePolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: 'Allow'
                Action: 'iam:PassRole'
                Resource: '*'
              - Effect: 'Allow'
                Action: 
                  - 'codebuild:StartBuild'
                  - 'codebuild:BatchGetBuilds'
                  - 'codebuild:BatchGetBuildBatches'
                  - 'codebuild:StartBuildBatch'
                Resource: '*'
              - Effect: 'Allow'
                Action: 'codestar-connections:UseConnection'
                Resource: !Ref ConnectionArn
              - Effect: 'Allow'
                Action: 
                  - 'ecs:CreateService'
                  - 'ecs:UpdateService'
                  - 'ecs:DeleteService'
                  - 'ecs:RegisterTaskDefinition'
                  - 'ecs:DeregisterTaskDefinition'
                  - 'ecs:DescribeServices'
                  - 'ecs:DescribeTaskDefinition'
                Resource: '*'
              - Effect: 'Allow'
                Action:
                  - 's3:PutObject'
                  - 's3:GetObject'
                  - 's3:GetObjectVersion'
                  - 's3:GetBucketVersioning'
                Resource:
                  - !Sub 'arn:aws:s3:::${BuildArtifactBucketName}/*'
                  - !Sub 'arn:aws:s3:::${BuildArtifactBucketName}'
              - Effect: 'Allow'
                Action:
                  - 's3:PutObject'
                Resource:
                  - !Sub 'arn:aws:s3:::${PlaywrightReportsBucketName}/*'
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-CodePipelineRole"
        - Key: Project
          Value: !FindInMap [TagMap, DefaultTags, Project]
        - Key: Environment
          Value: !FindInMap [TagMap, DefaultTags, Environment]

  CodeBuildRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Principal:
              Service:
                - 'codebuild.amazonaws.com'
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryFullAccess'
      Policies:
        - PolicyName: 'CodeBuildPolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: 'Allow'
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource:
                  - !Sub 'arn:aws:logs:${Region}:${AccountID}:log-group:/aws/codebuild/${BuildProjectName}'
                  - !Sub 'arn:aws:logs:${Region}:${AccountID}:log-group:/aws/codebuild/${BuildProjectName}:*'
                  - !Sub 'arn:aws:logs:${Region}:${AccountID}:log-group:/aws/codebuild/${TestProjectName}'
                  - !Sub 'arn:aws:logs:${Region}:${AccountID}:log-group:/aws/codebuild/${TestProjectName}:*'
              - Effect: 'Allow'
                Action:
                  - 's3:PutObject'
                  - 's3:GetObject'
                  - 's3:GetObjectVersion'
                  - 's3:GetBucketAcl'
                  - 's3:GetBucketLocation'
                  - 's3:ListBucket'
                Resource:
                  - !Sub 'arn:aws:s3:::${BuildArtifactBucketName}'
                  - !Sub 'arn:aws:s3:::${BuildArtifactBucketName}/*'
                  - !Sub 'arn:aws:s3:::${PlaywrightReportsBucketName}'
                  - !Sub 'arn:aws:s3:::${PlaywrightReportsBucketName}/*'
              - Effect: 'Allow'
                Action:
                  - 'codebuild:CreateReportGroup'
                  - 'codebuild:CreateReport'
                  - 'codebuild:UpdateReport'
                  - 'codebuild:BatchPutTestCases'
                  - 'codebuild:BatchPutCodeCoverages'
                Resource:
                  - !Sub 'arn:aws:codebuild:${Region}:${AccountID}:report-group/${BuildProjectName}-*'
                  - !Sub 'arn:aws:codebuild:${Region}:${AccountID}:report-group/${TestProjectName}-*'
              - Effect: 'Allow'
                Action:
                  - 'ecs:UpdateService'
                  - 'ecs:RegisterTaskDefinition'
                Resource: '*'
              - Effect: 'Allow'
                Action:
                  - 'secretsmanager:GetSecretValue'
                  - 'secretsmanager:DescribeSecret'
                Resource: 
                  - !Sub 'arn:aws:secretsmanager:${Region}:${AccountID}:secret:${AppRepositoryName}*'
              - Effect: 'Allow'
                Action:
                  - 'codeconnections:GetConnectionToken'
                  - 'codeconnections:GetConnection'
                  - 'codeconnections:UseConnection'
                Resource: !Ref ConnectionArn
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-CodeBuildRole"
        - Key: Project
          Value: !FindInMap [TagMap, DefaultTags, Project]
        - Key: Environment
          Value: !FindInMap [TagMap, DefaultTags, Environment]

  #-----------------------------------------------------------------------------
  # CodeBuild Projects
  #-----------------------------------------------------------------------------
  BuildProject:
    Type: 'AWS::CodeBuild::Project'
    Properties:
      Name: !Ref BuildProjectName
      Description: !Sub "Build project for ${AppRepositoryName}"
      Source:
        Type: CODEPIPELINE
        BuildSpec: 'buildspec.yml'
      Artifacts:
        Type: CODEPIPELINE
      Environment:
        ComputeType: !Ref ComputeType
        Image: !Ref BuildImageName
        Type: LINUX_CONTAINER
        PrivilegedMode: true
        EnvironmentVariables:
          - Name: IMAGE_REPO_NAME
            Value: !Ref ECRRepositoryName
            Type: PLAINTEXT
          - Name: AWS_DEFAULT_REGION
            Value: !Ref Region
            Type: PLAINTEXT
          - Name: CONTAINER_NAME
            Value: 'myapp'
            Type: PLAINTEXT
          - Name: AWS_ACCOUNT_ID
            Value: !Ref AccountID
            Type: PLAINTEXT
          - Name: ECR_REPOSITORY_URI
            Value: !Sub "${AccountID}.dkr.ecr.${Region}.amazonaws.com/${ECRRepositoryName}"
            Type: PLAINTEXT
      LogsConfig:
        CloudWatchLogs:
          Status: ENABLED
          GroupName: !Sub '/aws/codebuild/${BuildProjectName}'
          StreamName: 'build-log-stream'
      ServiceRole: !GetAtt CodeBuildRole.Arn
      TimeoutInMinutes: !Ref TimeoutMinutes
      Cache:
        Type: LOCAL
        Modes:
          - LOCAL_DOCKER_LAYER_CACHE
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-BuildProject"
        - Key: Project
          Value: !FindInMap [TagMap, DefaultTags, Project]
        - Key: Environment
          Value: !FindInMap [TagMap, DefaultTags, Environment]
  
  TestProject:
    Type: 'AWS::CodeBuild::Project'
    Properties:
      Name: !Ref TestProjectName
      Description: !Sub "Playwright test project for ${AppRepositoryName}"
      Source:
        Type: GITHUB
        Location: !Sub 'https://github.com/kazucch0925/${TestRepositoryName}.git'
        BuildSpec: 'buildspec.yml'
      Artifacts:
        Type: NO_ARTIFACTS
      Environment:
        ComputeType: !Ref ComputeType
        Image: !Ref TestImageName
        Type: LINUX_CONTAINER
        PrivilegedMode: true
        EnvironmentVariables:
          # TODO: Env for Playwright
          - Name: AWS_DEFAULT_REGION
            Value: !Ref Region
            Type: PLAINTEXT
          - Name: AWS_ACCOUNT_ID
            Value: !Ref AccountID
            Type: PLAINTEXT
          - Name: REPORT_S3_BUCKET
            Value: !Ref PlaywrightReportsBucketName
            Type: PLAINTEXT
          - Name: PLAYWRIGHT_BROWSERS_PATH
            Value: '/ms-playwright'
            Type: PLAINTEXT
          - Name: TARGET_URL
            Value: !Sub "https://todolist-sample.com"
            Type: PLAINTEXT
      LogsConfig:
        CloudWatchLogs:
          Status: ENABLED
          GroupName: !Sub '/aws/codebuild/${TestProjectName}'
          StreamName: 'test-log-stream'
      ServiceRole: !GetAtt CodeBuildRole.Arn
      TimeoutInMinutes: !Ref TimeoutMinutes
      Cache:
        Type: LOCAL
        Modes:
          - LOCAL_CUSTOM_CACHE
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-TestProject"
        - Key: Project
          Value: !FindInMap [TagMap, DefaultTags, Project]
        - Key: Environment
          Value: !FindInMap [TagMap, DefaultTags, Environment]

  #-----------------------------------------------------------------------------
  # CodePipeline
  #-----------------------------------------------------------------------------
  Pipeline:
    Type: 'AWS::CodePipeline::Pipeline'
    Properties:
      Name: !Ref PipelineName
      RoleArn: !GetAtt CodePipelineRole.Arn
      ArtifactStore:
        Type: S3
        Location: !Ref ArtifactBucket
      Stages:
        - Name: Source
          Actions:
            - Name: SourceAction
              ActionTypeId:
                Category: Source
                Owner: AWS
                Provider: CodeStarSourceConnection
                Version: 1
              OutputArtifacts:
                - Name: SourceArtifact
              Configuration:
                ConnectionArn: !Ref ConnectionArn
                FullRepositoryId: !Sub 'kazucch0925/${AppRepositoryName}'
                BranchName: !Ref AppRepositoryBranch
                DetectChanges: true
              RunOrder: 1
            - Name: TestSourceAction
              ActionTypeId:
                Category: Source
                Owner: AWS
                Provider: CodeStarSourceConnection
                Version: 1
              OutputArtifacts:
                - Name: TestSourceArtifact
              Configuration:
                ConnectionArn: !Ref ConnectionArn
                FullRepositoryId: !Sub 'kazucch0925/${TestRepositoryName}'
                BranchName: !Ref TestRepositoryBranch
                DetectChanges: true
              RunOrder: 1
        - Name: Build
          Actions:
            - Name: BuildAction
              ActionTypeId:
                Category: Build
                Owner: AWS
                Provider: CodeBuild
                Version: 1
              InputArtifacts:
                - Name: SourceArtifact
              OutputArtifacts:
                - Name: BuildArtifact
              Configuration:
                ProjectName: !Ref BuildProject
              RunOrder: 1
        - Name: Deploy
          Actions:
            - Name: DeployAction
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Provider: ECS
                Version: 1
              InputArtifacts:
                - Name: BuildArtifact
              Configuration:
                ClusterName: !Ref ECSClusterName
                ServiceName: !Ref ECSServiceName
                FileName: 'imagedefinitions.json'
              RunOrder: 1
        - Name: Test
          Actions:
            - Name: TestAction
              ActionTypeId:
                Category: Build
                Owner: AWS
                Provider: CodeBuild
                Version: 1
              InputArtifacts:
                - Name: TestSourceArtifact
              Configuration:
                ProjectName: !Ref TestProject
                PrimarySource: TestSourceArtifact
              RunOrder: 1
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-Pipeline"
        - Key: Project
          Value: !FindInMap [TagMap, DefaultTags, Project]
        - Key: Environment
          Value: !FindInMap [TagMap, DefaultTags, Environment]

  #-----------------------------------------------------------------------------
  # Notification Rules
  #-----------------------------------------------------------------------------
  CodePipelineNotificationRule:
    Type: 'AWS::CodeStarNotifications::NotificationRule'
    Properties:
      Name: !Sub "${AWS::StackName}-pipeline-notifications"
      DetailType: FULL
      EventTypeIds:
        - codepipeline-pipeline-pipeline-execution-failed
        - codepipeline-pipeline-pipeline-execution-succeeded
        - codepipeline-pipeline-pipeline-execution-started
      Resource: !Sub "arn:aws:codepipeline:${Region}:${AccountID}:${Pipeline}"
      Targets:
        - TargetType: SNS
          TargetAddress: !Ref PipelineNotificationTopic

  BuildProjectNotificationRule:
    Type: 'AWS::CodeStarNotifications::NotificationRule'
    Properties:
      Name: !Sub "${AWS::StackName}-build-notifications"
      DetailType: FULL
      EventTypeIds:
        - codebuild-project-build-state-failed
      Resource: !Sub "arn:aws:codebuild:${Region}:${AccountID}:project/${BuildProject}"
      Targets:
        - TargetType: SNS
          TargetAddress: !Ref PipelineNotificationTopic

  TestProjectNotificationRule:
    Type: 'AWS::CodeStarNotifications::NotificationRule'
    Properties:
      Name: !Sub "${AWS::StackName}-test-notifications"
      DetailType: FULL
      EventTypeIds:
        - codebuild-project-build-state-failed
      Resource: !Sub "arn:aws:codebuild:${Region}:${AccountID}:project/${TestProjectName}"
      Targets:
        - TargetType: SNS
          TargetAddress: !Ref PipelineNotificationTopic

Outputs:
  PipelineName:
    Description: "The name of the CodePipeline pipeline"
    Value: !Ref Pipeline
    Export:
      Name: !Sub "${AWS::StackName}-PipelineName"
  
  NotificationTopicArn:
    Description: "The ARN of the SNS topic used for notifications"
    Value: !Ref PipelineNotificationTopic
    Export:
      Name: !Sub "${AWS::StackName}-NotificationTopicArn"
  
  ArtifactBucketName:
    Description: "The name of the S3 bucket used to store pipeline artifacts"
    Value: !Ref ArtifactBucket
    Export:
      Name: !Sub "${AWS::StackName}-ArtifactBucketName"
  
  PlaywrightReportsBucketName:
    Description: "The name of the S3 bucket used to store Playwright test reports"
    Value: !Ref PlaywrightReportsBucket
    Export:
      Name: !Sub "${AWS::StackName}-PlaywrightReportsBucketName"
  
  ECRRepositoryName:
    Description: "The name of the ECR repository"
    Value: !Ref ECRRepository
    Export:
      Name: !Sub "${AWS::StackName}-ECRRepositoryName"
  
  ECRRepositoryURI:
    Description: "The URI of the ECR repository"
    Value: !Sub "${AccountID}.dkr.ecr.${Region}.amazonaws.com/${ECRRepositoryName}"
    Export:
      Name: !Sub "${AWS::StackName}-ECRRepositoryURI"
